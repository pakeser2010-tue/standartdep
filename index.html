<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Редстандарт — Помощник редактора</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* Custom TASS Colors */
        :root {
            --tass-blue: #221f73;
            --tass-white: #ffffff;
        }
        .bg-tass { background-color: var(--tass-blue); }
        .text-tass { color: var(--tass-blue); }
        .border-tass { border-color: var(--tass-blue); }
        
        body {
            font-family: 'Segoe UI', 'Roboto', Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
        }

        /* Loading Spinner */
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--tass-blue);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Markdown-like simple styling for bot responses */
        .prose p { margin-bottom: 0.5em; }
        .prose ul { list-style-type: disc; padding-left: 1.2em; margin-bottom: 0.5em; }
        .prose ol { list-style-type: decimal; padding-left: 1.2em; margin-bottom: 0.5em; }
        .prose li { margin-bottom: 0.25em; }
        .prose strong { font-weight: 600; }
    </style>
</head>
<body class="h-screen overflow-hidden">
    <div id="root" class="h-full flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const API_KEY = "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";
        
        // Define Document Map with new logic
        const DOCS_MAP = {
            INDEX: "https://raw.githubusercontent.com/pakeser2010-tue/standart/refs/heads/main/index.txt",
            MID: "https://raw.githubusercontent.com/pakeser2010-tue/standart/refs/heads/main/mid.txt",
            DOC_1: "https://raw.githubusercontent.com/pakeser2010-tue/standart/refs/heads/main/DOC_1_PRINCIPLES_AND_SOURCES.txt",
            DOC_2: "https://raw.githubusercontent.com/pakeser2010-tue/standart/refs/heads/main/DOC_2_MESSAGE_TYPES_AND_FORMATS.txt",
            DOC_3: "https://raw.githubusercontent.com/pakeser2010-tue/standart/refs/heads/main/DOC_3_NEWS_STRUCTURE.txt",
            DOC_4: "https://raw.githubusercontent.com/pakeser2010-tue/standart/refs/heads/main/DOC_4_PRODUCTION_AND_PUBLISHING.txt"
        };

        const ROUTER_SYSTEM_PROMPT = `
Вы — система маршрутизации запросов к базе знаний ТАСС.
Ваша задача: проанализировать запрос пользователя и ОГЛАВЛЕНИЕ (Index), чтобы определить, какой из 4 документов содержит ответ.

ДОКУМЕНТЫ:
DOC_1: Принципы, источники, этика, общие правила.
DOC_2: Виды сообщений, форматы (молния, срочно), заголовки.
DOC_3: Структура новости, лид, бэкграунд, цитаты, эмбарго.
DOC_4: Производство, выпуск, правка, работа с коррсетью.

ИНСТРУКЦИЯ:
- Верни ТОЛЬКО код документа: "DOC_1", "DOC_2", "DOC_3" или "DOC_4".
- Если запрос общий (приветствие, суть ТАСС) — верни "DOC_1".
- Если запрос не подходит ни под один, верни "DOC_1".
- НИКАКИХ дополнительных слов. Только код.
`;

        const FINAL_SYSTEM_PROMPT = `
Ты — помощник редактора информационного агентства ТАСС. Твоя задача — быстро находить ответы в редакционном стандарте.

КОНТЕКСТ РАБОТЫ:
Мы определили, что ответ на вопрос пользователя находится в загруженных ниже документах.
Используй ТОЛЬКО предоставленный текст для ответа.

ПРАВИЛА:
1. Отвечай только на основе <CONTEXT>.
2. Не придумывай правила, которых нет в тексте.
3. Если ответа нет — скажи: "В выбранном разделе стандарта информации по вашему запросу не найдено."
4. Стиль: деловой, без воды, конкретный.

<CONTEXT>
`;

        function App() {
            // Document contents
            const [docsContent, setDocsContent] = useState({
                INDEX: null,
                MID: null,
                DOC_1: null,
                DOC_2: null,
                DOC_3: null,
                DOC_4: null
            });
            
            const [isLoadingInit, setIsLoadingInit] = useState(true);
            const [loadError, setLoadError] = useState(null);
            
            const [messages, setMessages] = useState([
                { role: 'assistant', content: 'Здравствуйте. Я «Редстандарт» — обновленный помощник по стандартам ТАСС. Я использую алгоритм умного поиска по разделам. Задайте вопрос.' }
            ]);
            const [input, setInput] = useState("");
            const [isSending, setIsSending] = useState(false);
            const [statusMessage, setStatusMessage] = useState(""); // For UI feedback steps
            const [usedDoc, setUsedDoc] = useState(null); // Which doc was used for the last answer
            
            const messagesEndRef = useRef(null);

            // Fetch Index and MID on mount
            useEffect(() => {
                const initLoad = async () => {
                    try {
                        setStatusMessage("Инициализация базы...");
                        const [resIndex, resMid] = await Promise.all([
                            fetch(DOCS_MAP.INDEX),
                            fetch(DOCS_MAP.MID)
                        ]);

                        if (!resIndex.ok) throw new Error("Ошибка загрузки Index");
                        if (!resMid.ok) throw new Error("Ошибка загрузки MID");

                        const textIndex = await resIndex.text();
                        const textMid = await resMid.text();

                        setDocsContent(prev => ({
                            ...prev,
                            INDEX: textIndex,
                            MID: textMid
                        }));
                        console.log("INDEX and MID loaded.");
                    } catch (err) {
                        console.error("Init Error:", err);
                        setLoadError(err.message);
                    } finally {
                        setIsLoadingInit(false);
                        setStatusMessage("");
                    }
                };

                initLoad();
            }, []);

            // Scroll to bottom
            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            // Helper to fetch specific doc if not loaded
            const ensureDocLoaded = async (docKey) => {
                if (docsContent[docKey]) return docsContent[docKey];

                setStatusMessage(`Загрузка раздела ${docKey}...`);
                try {
                    const res = await fetch(DOCS_MAP[docKey]);
                    if (!res.ok) throw new Error(`Не удалось загрузить ${docKey}`);
                    const text = await res.text();
                    
                    setDocsContent(prev => ({ ...prev, [docKey]: text }));
                    return text;
                } catch (e) {
                    console.error(e);
                    throw e;
                }
            };

            const handleSend = async (e) => {
                e.preventDefault();
                if (!input.trim() || isSending || isLoadingInit) return;

                const userQuery = input.trim();
                const userMessage = { role: 'user', content: userQuery };
                
                setMessages(prev => [...prev, userMessage]);
                setInput("");
                setIsSending(true);
                setUsedDoc(null);

                try {
                    // STEP 1: ROUTING
                    setStatusMessage("Анализ запроса (выбор документа)...");
                    
                    if (!docsContent.INDEX) throw new Error("Индекс не загружен");

                    const routerResponse = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                        method: "POST",
                        headers: {
                            "Authorization": `Bearer ${API_KEY}`,
                            "Content-Type": "application/json",
                            "HTTP-Referer": window.location.href,
                            "X-Title": "Redstandart TASS Router"
                        },
                        body: JSON.stringify({
                            model: "meta-llama/llama-3.3-70b-instruct:free",
                            messages: [
                                { 
                                    role: "system", 
                                    content: ROUTER_SYSTEM_PROMPT + `\n\nОГЛАВЛЕНИЕ:\n${docsContent.INDEX}`
                                },
                                { role: "user", content: `Запрос: ${userQuery}` }
                            ],
                            temperature: 0.0,
                            max_tokens: 10
                        })
                    });

                    // Check if router response is OK
                    if (!routerResponse.ok) {
                        const errorData = await routerResponse.json().catch(() => ({}));
                        console.error("Router API Error:", errorData);
                        throw new Error(errorData.error?.message || `Ошибка API роутера: ${routerResponse.status}`);
                    }

                    const routerData = await routerResponse.json();
                    
                    // Check for API error in response body
                    if (routerData.error) {
                        console.error("Router returned error:", routerData.error);
                        throw new Error(routerData.error.message || "Ошибка маршрутизации");
                    }

                    // *** FIX: Safely extract targetDoc with null checks ***
                    let rawContent = routerData.choices?.[0]?.message?.content;
                    let targetDoc;

                    if (rawContent && typeof rawContent === 'string') {
                        targetDoc = rawContent.trim().toUpperCase().replace(/[^A-Z0-9_]/g, '');
                    } else {
                        console.warn("Router returned empty or invalid content:", rawContent);
                        targetDoc = "DOC_1"; // Default fallback
                    }
                    
                    // Fallback validation
                    const validDocs = ["DOC_1", "DOC_2", "DOC_3", "DOC_4"];
                    if (!validDocs.includes(targetDoc)) {
                        console.warn("Router returned invalid doc:", targetDoc, "- defaulting to DOC_1");
                        targetDoc = "DOC_1"; // Default fallback
                    }

                    console.log(`Router selected: ${targetDoc}`);

                    // STEP 2: FETCHING TARGET DOC
                    const docText = await ensureDocLoaded(targetDoc);

                    // STEP 3: GENERATING ANSWER
                    setStatusMessage(`Генерация ответа по ${targetDoc}...`);
                    setUsedDoc(targetDoc);

                    const fullContext = `
=== MAIN DOCUMENT (${targetDoc}) ===
${docText}

=== MID CONTEXT (APPENDIX) ===
${docsContent.MID || ''}
`;

                    const finalSystemMessage = FINAL_SYSTEM_PROMPT + fullContext + "\n</CONTEXT>";

                    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                        method: "POST",
                        headers: {
                            "Authorization": `Bearer ${API_KEY}`,
                            "Content-Type": "application/json",
                            "HTTP-Referer": window.location.href,
                            "X-Title": "Redstandart TASS Main"
                        },
                        body: JSON.stringify({
                            model: "meta-llama/llama-3.3-70b-instruct:free",
                            messages: [
                                { role: "system", content: finalSystemMessage },
                                ...messages.slice(-2), // Only very recent context to keep focus on the doc
                                userMessage
                            ],
                            temperature: 0.1,
                            max_tokens: 1200
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || "Ошибка API при генерации ответа");
                    }

                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error.message || "Ошибка генерации ответа");
                    }

                    const aiContent = data.choices?.[0]?.message?.content || "Не удалось сгенерировать ответ.";

                    setMessages(prev => [...prev, { role: 'assistant', content: aiContent, meta: targetDoc }]);

                } catch (error) {
                    console.error("Chain Error:", error);
                    setMessages(prev => [...prev, { role: 'assistant', content: `Ошибка: ${error.message}. Попробуйте еще раз.` }]);
                } finally {
                    setIsSending(false);
                    setStatusMessage("");
                }
            };

            // Formatting helper for simple markdown
            const formatText = (text) => {
                // Split by newlines and wrap paragraphs
                return text.split('\n').map((str, index) => {
                    if (!str.trim()) return <br key={index} />;
                    // Simple bold handling **text**
                    const parts = str.split(/(\*\*.*?\*\*)/g);
                    return (
                        <p key={index} className="mb-1">
                            {parts.map((part, i) => {
                                if (part.startsWith('**') && part.endsWith('**')) {
                                    return <strong key={i}>{part.slice(2, -2)}</strong>;
                                }
                                return part;
                            })}
                        </p>
                    );
                });
            };

            return (
                <div className="flex flex-col h-full max-w-2xl mx-auto bg-white shadow-2xl relative">
                    {/* Header */}
                    <header className="bg-tass text-white p-4 flex items-center justify-between shadow-md z-10">
                        <div className="flex items-center gap-3">
                            <div className="w-10 h-10 bg-white rounded-full flex items-center justify-center text-tass font-bold text-xl">
                                Т
                            </div>
                            <div>
                                <h1 className="font-bold text-lg leading-tight">Редстандарт</h1>
                                <p className="text-xs opacity-80 font-light">Помощник ТАСС</p>
                            </div>
                        </div>
                        <div className="text-xs text-right">
                            {isLoadingInit ? (
                                <span className="flex items-center gap-2 text-yellow-300">
                                    <div className="loader w-3 h-3 border-white border-t-transparent"></div>
                                    Загрузка базы...
                                </span>
                            ) : loadError ? (
                                <span className="text-red-300">Ошибка подключения</span>
                            ) : (
                                <span className="text-green-300 flex items-center gap-1" title="Индекс и приложение активны">
                                    <i className="ph ph-check-circle"></i> Индекс активен
                                </span>
                            )}
                        </div>
                    </header>

                    {/* Chat Area */}
                    <main className="flex-1 overflow-y-auto p-4 bg-gray-50 scroll-smooth">
                        {loadError && (
                            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded mb-4 text-sm">
                                <strong>Ошибка:</strong> {loadError}
                            </div>
                        )}
                        
                        <div className="space-y-4 pb-2">
                            {messages.map((msg, idx) => (
                                <div 
                                    key={idx} 
                                    className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
                                >
                                    <div 
                                        className={`max-w-[85%] px-4 py-3 rounded-2xl shadow-sm text-sm leading-relaxed prose ${
                                            msg.role === 'user' 
                                                ? 'bg-tass text-white rounded-tr-none' 
                                                : 'bg-white border border-gray-200 text-gray-800 rounded-tl-none'
                                        }`}
                                    >
                                        {formatText(msg.content)}
                                        {msg.meta && (
                                            <div className="mt-2 pt-2 border-t border-gray-100 text-[10px] text-gray-400 font-mono flex items-center gap-1">
                                                <i className="ph ph-file-text"></i> Источник: {msg.meta}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            ))}
                            {isSending && (
                                <div className="flex justify-start">
                                    <div className="bg-white border border-gray-200 px-4 py-3 rounded-2xl rounded-tl-none shadow-sm flex flex-col gap-2 min-w-[150px]">
                                        <div className="flex gap-2 items-center">
                                            <div className="w-2 h-2 bg-tass rounded-full animate-bounce" style={{animationDelay: '0ms'}}></div>
                                            <div className="w-2 h-2 bg-tass rounded-full animate-bounce" style={{animationDelay: '150ms'}}></div>
                                            <div className="w-2 h-2 bg-tass rounded-full animate-bounce" style={{animationDelay: '300ms'}}></div>
                                        </div>
                                        {statusMessage && (
                                            <span className="text-xs text-tass font-medium animate-pulse">{statusMessage}</span>
                                        )}
                                    </div>
                                </div>
                            )}
                            <div ref={messagesEndRef} />
                        </div>
                    </main>

                    {/* Input Area */}
                    <footer className="p-4 bg-white border-t border-gray-200">
                        <form onSubmit={handleSend} className="relative flex items-center gap-2">
                            <input
                                type="text"
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                placeholder={isLoadingInit ? "Подключение к базе знаний..." : "Спросите о правилах (например: 'как оформить цитату?')"}
                                disabled={isLoadingInit || isSending}
                                className="w-full bg-gray-100 text-gray-900 border-0 rounded-full py-3 pl-5 pr-12 focus:ring-2 focus:ring-[#221f73] focus:bg-white transition-all outline-none disabled:opacity-60"
                            />
                            <button 
                                type="submit" 
                                disabled={!input.trim() || isLoadingInit || isSending}
                                className="absolute right-2 w-8 h-8 flex items-center justify-center bg-tass text-white rounded-full hover:bg-opacity-90 disabled:bg-gray-400 transition-colors"
                            >
                                <i className="ph ph-paper-plane-right text-lg"></i>
                            </button>
                        </form>
                        <div className="text-center mt-2">
                             <p className="text-[10px] text-gray-400">
                                Smart Search: INDEX → DOC SELECT → ANSWER. Powered by Llama-3.
                             </p>
                        </div>
                    </footer>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
